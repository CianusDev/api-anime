"use strict";
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const node_fetch_1 = require("node-fetch");
const node_html_parser_1 = require("node-html-parser");
const os_1 = require("os");
const ffmpeg = require("ffmpeg-static");
class Anime {
    //NORMAL
    names = {
        english: "",
        french: "",
        romanji: "",
        other: "",
        normal: ""
    };
    genres = [];
    type = "TV";
    cover = "";
    url = Constants.BASE;
    episodesCount = 0;
    score = 0;
    releaseYear = 0;
    status = ANIMESTATUS[2];
    //ADD
    #background = null;
    get background() { return this.#background; }
    #episodes = [];
    get episodes() { return this.#episodes; }
    constructor(data) {
        this.status = ANIMESTATUS[+data.status];
        this.cover = data.url_image;
        this.episodesCount = +data.nb_eps.split(" ")[0];
        this.genres = data.genres;
        this.releaseYear = +data.start_date_year;
        this.score = +data.score;
        this.type = data.type.toUpperCase();
        this.url += data.url;
        this.names = {
            english: data.title_english,
            french: data.title_french,
            romanji: data.title_romanji,
            other: data.others,
            normal: data.title
        };
    }
    get preferedName() {
        return this.names.english || this.names.normal || this.names.romanji || this.names.french || this.names.other;
    }
    async fetchAllInformations() {
        const html = node_html_parser_1.default(await node_fetch_1.default(this.url).then(res => res.text()));
        const epsInfos = JSON.parse(html.querySelector('#main').querySelector('script').innerText.split("episodes = ")[1].split(";")[0]);
        const background = html.querySelector('#head').getAttribute("style").split("url(")[1].split(")")[0];
        this.#background = background;
        this.#episodes = [];
        for (let ep of epsInfos) {
            this.#episodes.push(new Episode(this, ep));
        }
    }
}
class Episode {
    //NORMAL
    anime;
    episodeCount;
    time;
    url = Constants.BASE;
    cover;
    //ADD
    #stream;
    get stream() { return this.#stream; }
    constructor(anime, data) {
        this.anime = anime;
        this.episodeCount = +data.episode.split(" ")[1];
        this.time = +data.time.split(" ")[0];
        this.url += data.url;
        this.cover = data.url_image;
    }
    async fetchStreamData() {
        const html = node_html_parser_1.default(await node_fetch_1.default(this.url).then(res => res.text()));
        let url;
        try {
            url = "https://www.pstream.net/e/" + html.querySelector("body").querySelectorAll("script").find(e => e['rawAttrs'] == 'type="text/javascript"').innerText.split("https://www.pstream.net/e/")[1].split("'")[0];
        }
        catch (e) {
            url = "https://fusevideo.net/e/" + html.querySelector("body").querySelectorAll("script").find(e => e['rawAttrs'] == 'type="text/javascript"').innerText.split("https://fusevideo.net/e/")[1].split("'")[0];
        }
        this.#stream = new StreamData(this, url);
        await this.#stream.waitLoaded();
    }
}
class StreamData {
    #end = false;
    #subs;
    #video = [];
    url;
    episode;
    get subtitles() { return this.#subs; }
    get streams() { return this.#video; }
    constructor(episode, url) {
        this.url = url;
        this.episode = episode;
        console.log(url);
        this.#superFetch(url)
            .then(res => res.text())
            .then(async (text) => {
            const html = node_html_parser_1.default(text);
            const sub = html.querySelector("track");
            if (sub) {
                this.#subs = await this.#superFetch(sub.getAttribute("src")).then(res => res.text());
            }
            let videoJSURL;
            try {
                videoJSURL = "https://www.pstream.net/u/player-script" + text.split("https://www.pstream.net/u/player-script")[1].split('"')[0];
            }
            catch (e) {
                videoJSURL = "https://fusevideo.net/u/player-script" + text.split("https://fusevideo.net/u/player-script")[1].split('"')[0];
            }
            const videoJS = await this.#superFetch(videoJSURL).then(res => res.text());
            const streamsURL = JSON.parse(atob(videoJS.split('atob(t).slice(2))')[1].split("}(\"")[1].split('")')[0]).slice(2));
            const streams = await this.#superFetch(Object.values(streamsURL).find(e => typeof e === "string")).then(res => res.text());
            const lines = streams.split("\n");
            lines.shift();
            let bef = "";
            for (let line of lines) {
                if (line.startsWith("#"))
                    bef = line;
                else if (line.startsWith("http")) {
                    this.#video.push({
                        data: await this.#superFetch(line).then(res => res.text()),
                        size: {
                            height: +bef.split("RESOLUTION=")[1].split(",")[0].split("x")[1],
                            width: +bef.split("RESOLUTION=")[1].split(",")[0].split("x")[0]
                        }
                    });
                }
            }
            this.#end = true;
        });
    }
    waitLoaded() {
        return new Promise(res => {
            const x = setInterval(() => {
                if (this.#end) {
                    res();
                    clearInterval(x);
                }
            }, 100);
        });
    }
    #superFetch(url) {
        return node_fetch_1.default(url, {
            "headers": {
                "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
                "accept-language": "fr,fr-FR;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6",
                "cache-control": "no-cache",
                "pragma": "no-cache",
                "sec-ch-ua": "\"Chromium\";v=\"92\", \" Not A;Brand\";v=\"99\", \"Microsoft Edge\";v=\"92\"",
                "sec-ch-ua-mobile": "?0",
                "sec-fetch-dest": "iframe",
                "sec-fetch-mode": "navigate",
                "sec-fetch-site": "cross-site",
                "upgrade-insecure-requests": "1"
            },
            "referrerPolicy": "no-referrer",
            "body": null,
            "method": "GET",
            "mode": "cors"
        });
    }
}
class NekoSama {
    DATAS = {
        VOSTFR: [],
        VF: []
    };
    constructor() {
        node_fetch_1.default(Constants.LIST.VOSTFR)
            .then(res => res.text())
            .then(txt => this.DATAS.VOSTFR = JSON.parse(txt));
        node_fetch_1.default(Constants.LIST.VF)
            .then(res => res.text())
            .then(txt => this.DATAS.VF = JSON.parse(txt));
    }
    onReady() {
        return new Promise(res => {
            const x = setInterval(() => {
                if (this.ready) {
                    res();
                    clearInterval(x);
                }
            }, 100);
        });
    }
    get ready() {
        return this.DATAS.VF.length > 0 && this.DATAS.VOSTFR.length > 0;
    }
    async search(query, type = "VOSTFR") {
        await this.onReady();
        const endArr = [];
        for (let anime of this.DATAS[type]) {
            const titles = Object.values(anime).filter(e => Object.keys(anime)[Object.values(anime).indexOf(e)].includes("title") || Object.keys(anime)[Object.values(anime).indexOf(e)] == "others");
            for (let title of titles) {
                if (title != null && title.toLowerCase().includes(query.toLowerCase())) {
                    endArr.push(new Anime(anime));
                    break;
                }
            }
        }
        return endArr;
    }
    getAnimeByURL(url) {
        const anime = this.DATAS.VOSTFR.find(e => e.url == url) || this.DATAS.VF.find(e => e.url == url);
        if (anime)
            return new Anime(anime);
    }
    async download(stream, qual = 1080, path, process = () => { }) {
        const cptest = child_process_1.spawnSync("ffmpeg");
        if (cptest.error) {
            throw new Error("Please install FFMPEG before (npm i ffmpeg-static)");
        }
        const select = stream.streams.find(e => e.size.height == qual);
        if (!select)
            throw new Error("No stream found with quality " + qual);
        const videoPath = os_1.tmpdir().replaceAll("\\", "/") + "/video.m3u8";
        const subsPath = os_1.tmpdir().replaceAll("\\", "/") + "/subs.m3u8";
        fs_1.writeFileSync(videoPath, select.data);
        if (stream.subtitles)
            fs_1.writeFileSync(subsPath, stream.subtitles);
        const cp = child_process_1.spawn(ffmpeg, [
            "-y",
            "-protocol_whitelist", "file,http,https,tcp,tls",
            "-i", videoPath,
            ...(stream.subtitles ? ["-vf", "subtitles=" + subsPath.replaceAll(":", "\\\\:")] : []),
            path
        ]);
        const lastData = {
            duration: "",
            current: "",
            speed: 0,
            size: "",
            raw: ""
        };
        const processing = (data) => {
            const txt = data.toString();
            lastData.raw = txt;
            if (txt.includes("Duration: ")) {
                lastData.duration = txt.split("Duration: ")[1].split(",")[0];
            }
            if (txt.includes("bitrate=")) {
                lastData.size = txt.split("size=")[1].replaceAll(" ", "").split("time")[0];
                lastData.current = txt.split("time=")[1].split(" ")[0];
                lastData.speed = +txt.split("speed=")[1].split("x")[0];
                process(lastData);
            }
        };
        cp.stdout.on("data", processing);
        cp.stderr.on("data", processing);
        await new Promise(res => {
            cp.on("close", res);
        });
    }
}
const Constants = {
    BASE: "https://neko-sama.fr",
    LIST: {
        VOSTFR: "https://neko-sama.fr/animes-search-vostfr.json",
        VF: "https://neko-sama.fr/animes-search-vf.json"
    }
};
var ANIMESTATUS;
(function (ANIMESTATUS) {
    ANIMESTATUS[ANIMESTATUS["ACTUAL"] = 1] = "ACTUAL";
    ANIMESTATUS[ANIMESTATUS["FINISHED"] = 2] = "FINISHED";
})(ANIMESTATUS || (ANIMESTATUS = {}));
module.exports = new NekoSama();
